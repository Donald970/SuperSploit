# python3 module_test.py RHOST='' RPORT='' EXE='' UID=''
import json

from ..Logging import Logger
import subprocess
import traceback

try:
    from prompt_toolkit import prompt
    input = prompt
except ImportError:
    print("using standard input function no io control available")
    Logger.__start_logger_object__("Prompt toolkit not installed.")
    pass

integrated = False
from .database import jsdm
import os
config = f"/home/{os.getlogin()}/SuperSploit/.data/.config/config.json"
from ..Logging import Logger
with open(config, 'r') as file:
    config_dict = json.load(file)
    file.close()

install_location = config_dict["install_location"]
tmp_exploit_package_path = f"{install_location}/core/start/integrated_exploits/"

class exploit(Logger):

    def __init__(self):
        return

    @classmethod
    def py_setup(cls, vars, db, args):
        if input("Would you like import this exploit as a module [y/n]: ").startswith("y"):
            print(f"[*] Copying exploit to module path")
            with open(db["EXPLOIT"], "r") as file:
                fileR = file.read()
                file.close()

            with open(f"{tmp_exploit_package_path}/tmp.py", "w") as fileW:
                fileW.write(fileR)
                fileW.close()

            print("[*] Populating __init__ file")
            with open(f"{tmp_exploit_package_path}/__init__.py", "w") as file:
                file.write("from .tmp import exploit")
                file.close()

            print("[*] module Created successfully")
            cls.run_python_exploit_as_module(vars, db)
            return
        print("[*] Running as a python script with subprocess")
        cls.run_python_exploit(vars, db, args)

    @classmethod
    def sh_setup(cls, vars, db, args):
        print("[*] Exploit is a shell file")
        return

    @classmethod
    def exploit(cls, da):
        print("[*] Reading json database -> .data/data.json")
        db = jsdm.checkDb()

        print("[*] Creating required arguments")
        file = db["EXPLOIT"]
        vars = []
        args = ""

        print("[*] Creating input check list")
        types = ["py", "sh"]
        fun = [cls.py_setup, cls.sh_setup]

        print("[*] Reading exploit file")
        with open(file, "r") as rfile:
            data = rfile.read().split("# DETAILS #")
            rfile.close()

        print("[*] Exploit loaded successfully")
        fileList = str(data[1]).split("\n")
        for z in fileList:
            if fileList.index(z) > 0:
                if fileList.index(z) == len(fileList) - 1:
                    break
                vars.append(z.split(" ")[1])

        print("[*] Required arguments loaded")
        for z in vars:
            for k, v in db.items():
                if z == k:
                    args += (f"{k}={v} ")

        print("[*] Argument string created")
        type = file.split("/")[len(file.split('/')) -1].split(".")[1]
        print(f"[*] Using sting {args} for arguments")

        print(f"[*] Obtained exploit type: {type}")
        if type in types:
            fun[types.index(type)](vars, db, args)

    @classmethod
    def run_python_exploit(cls, vars, db, args):
        from subprocess import run
        print(f'[*] Running the command\n[*] python3 {db["EXPLOIT"]} {args}')
        run(["python3", f'{db["EXPLOIT"]}', f'{args}'],)
        print("[*] exploit completed")
        return

    @classmethod
    def run_python_exploit_as_module(cls, args, db):
        l = []
        for x in args:
            for k, v in db.items():
                if x == k:
                    l.append(v)
        try:
            print("[*] Trying to import")
            from .integrated_exploits import exploit
            print(f"[*] imported successfully\n[*] Trying to run with supplied arguments {l}")
            exploit(l)
            print("[*] Exploit completed successfully\n[*] Cleaning up")
            subprocess.run(["rm", f"{tmp_exploit_package_path}/tmp.py"])
            with open(f"{tmp_exploit_package_path}/__init__.py", "w") as file:
                file.write("")
                file.close()
            return True
        except Exception as e:
            cls.__start_logger_object__(str(traceback.format_exc()))
            print(e)
